{% extends "base.html" %}
{% from "components/loading_components.html" import loading_indicator %}

{% block title %}Risk Overview{% endblock %}

{% block head_extras %}
<style>
    /* Page title with icon variant */
    .page-title.has-icon {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
    }

    .page-title.has-icon i {
        color: var(--aqua-500);
    }

    /* Cash Toggle Styling */
    .cash-toggle-container {
        margin-top: var(--space-md);
        padding-top: var(--space-md);
        border-top: 1px solid var(--border-subtle);
    }

    .cash-toggle {
        display: inline-flex;
        align-items: center;
        gap: var(--space-sm);
        cursor: pointer;
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        transition: background-color var(--transition-base);
    }

    .cash-toggle:hover {
        background-color: var(--hover-bg);
    }

    .cash-toggle input[type="checkbox"] {
        margin-right: var(--space-xs);
    }

    .cash-toggle-label {
        display: inline-flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.875rem;
        color: var(--text-secondary);
    }

    .cash-toggle-label i {
        color: var(--aqua-500);
    }

    .cash-balance-tag {
        font-size: 0.75rem;
        display: none;
    }

    .cash-balance-tag.is-visible {
        display: inline-flex;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <!-- Loading indicator -->
    <div id="loadingIndicator">
        {{ loading_indicator('Loading portfolio data...') }}
    </div>

    <div id="analysisContent" style="display: none;">
        <!-- Apple-Inspired Portfolio Selection -->
        <div class="portfolio-selection-section">
            <h3 class="portfolio-subtitle">Portfolio Selection</h3>

            <div class="portfolio-pills" id="portfolioPills">
                <!-- Dynamic portfolio pills will be added here -->
            </div>

            <!-- Cash Toggle -->
            <div class="cash-toggle-container">
                <label class="checkbox cash-toggle">
                    <input type="checkbox" id="includeCashToggle">
                    <span class="cash-toggle-label">
                        <i class="fas fa-coins"></i>Include Cash
                    </span>
                    <span id="cashBalanceDisplay" class="tag is-info is-light cash-balance-tag sensitive-value"></span>
                </label>
            </div>
        </div>

        <!-- Apple-Inspired Global Overview -->
        <div class="global-overview-section">

            <!-- Overview Charts Grid (2 per row) -->
            <div class="columns is-multiline mb-4">
                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">Portfolio Distribution</div>
                                <div class="overview-chart-subtitle" id="portfolioCountSubtitle">Loading portfolios...
                                </div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="portfolioAllocationsChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">All Holdings</div>
                                <div class="overview-chart-subtitle" id="companyCountSubtitle">Across all portfolios
                                </div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="companyAllocationsChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">Geographic Spread</div>
                                <div class="overview-chart-subtitle" id="countryCountSubtitle">Countries represented
                                </div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="countryDistributionChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">Investment Thesis</div>
                                <div class="overview-chart-subtitle" id="thesisCountSubtitle">Thesis breakdown</div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="thesisDistributionChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">Investment Types</div>
                                <div class="overview-chart-subtitle" id="investmentTypeSubtitle">Stock vs ETF breakdown</div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="investmentTypeChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="column is-6">
                    <div class="gauge-card">
                        <div class="gauge-indicator">
                            <div class="overview-chart-header">
                                <div class="overview-chart-title">User Sectors</div>
                                <div class="overview-chart-subtitle" id="sectorCountSubtitle">Sector breakdown</div>
                            </div>
                            <div class="overview-chart-container">
                                <div id="sectorDistributionChart"></div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Risk indicators removed - now only available on main page -->
    </div>
</div>

{% include "components/analyse_components.html" %}

<!-- Load centralized value calculator utility -->
<script src="{{ url_for('static', filename='js/utils/value-calculator.js') }}"></script>

<!-- JavaScript for Risk Overview -->
<script>
    /**
     * Risk Overview - Global Portfolio Analysis
     * 
     * This script provides a high-level overview of portfolio allocations and distributions.
     * Features include:
     * - Portfolio allocation visualization
     * - Company allocation across all portfolios
     * - Distribution breakdowns by country and sector
     */
    document.addEventListener('DOMContentLoaded', function () {
        console.log('DOM loaded, initializing Risk Overview...');

        // Check if required dependencies are loaded
        if (typeof ApexCharts === 'undefined') {
            console.error('ApexCharts is not loaded');
            document.getElementById('loadingIndicator').innerHTML = `
            <div class="has-text-centered">
                <p class="has-text-danger mb-3">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    Required chart library (ApexCharts) is not loaded.
                </p>
                <button class="button is-info" onclick="location.reload()">
                    <i class="fas fa-refresh mr-2"></i>Try Again
                </button>
            </div>
        `;
            return;
        }

        // Store data
        let portfolioData = [];
        let charts = {};
        let selectedPortfolios = new Set();
        let portfolioAllocationsChart = null;
        let companyAllocationsChart = null;
        let allocationRules = {
            maxPerStock: null,
            maxPerSector: null,
            maxPerCountry: null
        };
        // Cash state
        let cashBalance = 0;
        let includeCash = false;

        // Utility functions for formatting
        window.formatCurrency = function (value) {
            if (typeof value !== 'number' || isNaN(value)) return '<span class="sensitive-value">â‚¬0</span>';
            const formatted = 'â‚¬' + value.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            });
            return `<span class="sensitive-value">${formatted}</span>`;
        };

        window.formatPercentage = function (value) {
            if (typeof value !== 'number' || isNaN(value)) return '0%';
            return value.toFixed(1) + '%';
        };



        // Initialize the risk overview
        initializeRiskOverview();

        function initializeRiskOverview() {
            // Data loading is now handled by the Promise.all call below
        }

        // Load data and initialize
        console.log('Starting data loading process...');

        // Check if we have all required dependencies
        console.log('Checking dependencies...');
        console.log('ApexCharts available:', typeof ApexCharts !== 'undefined');
        console.log('ChartConfig available:', typeof ChartConfig !== 'undefined');

        if (typeof ApexCharts === 'undefined') {
            console.error('ApexCharts library not loaded');
            document.getElementById('loadingIndicator').innerHTML = `
            <p class="has-text-danger">ApexCharts library not loaded</p>
            <p class="has-text-grey">Please check your internet connection and reload the page.</p>
            <button class="button is-info mt-3" onclick="location.reload()">Try Again</button>
        `;
            return;
        }

        if (typeof ChartConfig === 'undefined') {
            console.error('ChartConfig module not loaded');
            document.getElementById('loadingIndicator').innerHTML = `
            <p class="has-text-danger">Chart configuration not loaded</p>
            <p class="has-text-grey">Please check your internet connection and reload the page.</p>
            <button class="button is-info mt-3" onclick="location.reload()">Try Again</button>
        `;
            return;
        }

        console.log('All dependencies loaded successfully');

        // Fetch allocation rules from the server
        async function fetchAllocationRules() {
            console.log('Fetching allocation rules...');
            try {
                const response = await fetch('/portfolio/api/state?page=build');
                console.log('Allocation rules API response status:', response.status);

                if (!response.ok) {
                    console.log('No allocation rules found (this is normal if none have been set)');
                    return null;
                }

                const data = await response.json();
                console.log('State data received:', data);

                if (data && data.rules) {
                    const rules = JSON.parse(data.rules);
                    console.log('Parsed allocation rules:', rules);
                    return rules;
                }

                return null;
            } catch (error) {
                console.log('Error fetching allocation rules (this is normal if none have been set):', error);
                return null;
            }
        }

        // Fetch saved state for risk_overview page (portfolio selection persistence)
        async function fetchSavedState() {
            console.log('Fetching saved state for risk_overview...');
            try {
                const response = await fetch('/portfolio/api/state?page=risk_overview');
                if (!response.ok) {
                    console.log('No saved state found (this is normal on first visit)');
                    return null;
                }
                const data = await response.json();
                console.log('Saved state received:', data);
                return data;
            } catch (error) {
                console.log('Error fetching saved state:', error);
                return null;
            }
        }

        // Fetch cash balance from account
        async function fetchCashBalance() {
            console.log('Fetching cash balance...');
            try {
                const response = await fetch('/portfolio/api/account/cash');
                if (!response.ok) {
                    console.log('No cash balance found');
                    return 0;
                }
                const data = await response.json();
                console.log('Cash balance received:', data);
                return data.cash || 0;
            } catch (error) {
                console.log('Error fetching cash balance:', error);
                return 0;
            }
        }

        // Save portfolio selection state (debounced)
        let saveTimeout = null;
        function savePortfolioSelection() {
            // Clear any pending save
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            // Debounce: wait 500ms before saving
            saveTimeout = setTimeout(async () => {
                try {
                    const stateData = {
                        page: 'risk_overview',
                        selectedPortfolios: JSON.stringify(Array.from(selectedPortfolios)),
                        includeCash: includeCash.toString()
                    };
                    console.log('Saving portfolio selection:', stateData);
                    const response = await fetch('/portfolio/api/state', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(stateData)
                    });
                    if (response.ok) {
                        console.log('Portfolio selection saved successfully');
                    } else {
                        console.warn('Failed to save portfolio selection:', response.status);
                    }
                } catch (error) {
                    console.error('Error saving portfolio selection:', error);
                }
            }, 500);
        }

        // Add timeout to prevent infinite loading
        const loadingTimeout = setTimeout(() => {
            console.error('Loading timeout reached');
            document.getElementById('loadingIndicator').innerHTML = `
            <div class="has-text-centered">
                <p class="has-text-danger mb-3">
                    <i class="fas fa-clock mr-2"></i>
                    Loading is taking longer than expected.
                </p>
                <p class="has-text-grey mb-3">
                    This might indicate a server issue or authentication problem.
                </p>
                <button class="button is-info" onclick="location.reload()">
                    <i class="fas fa-refresh mr-2"></i>Try Again
                </button>
            </div>
        `;
        }, 30000); // 30 second timeout

        Promise.all([
            fetchPortfolios(),
            fetchPortfolioData(),
            fetchAllocationRules(),
            fetchSavedState(),
            fetchCashBalance()
        ]).then(([portfoliosList, data, rules, savedState, cash]) => {
            clearTimeout(loadingTimeout); // Clear the timeout since we got a response
            console.log('Data loaded successfully, processing...');
            console.log('Portfolios list:', portfoliosList);
            console.log('Portfolio data:', data);

            try {
                // Process the data
                processData(portfoliosList, data);

                // Store allocation rules
                if (rules) {
                    allocationRules = rules;
                    console.log('Allocation rules loaded:', allocationRules);
                }

                // Store cash balance and update display
                cashBalance = cash || 0;
                console.log('Cash balance loaded:', cashBalance);
                updateCashDisplay();

                console.log('Data processed successfully, initializing UI...');

                // Initialize portfolio selection: restore from saved state or default to all
                const portfolios = portfolioData.map(p => p.name);
                if (savedState && savedState.selectedPortfolios) {
                    try {
                        const savedSelection = JSON.parse(savedState.selectedPortfolios);
                        // Only restore portfolios that still exist
                        const validSelection = savedSelection.filter(name => portfolios.includes(name));
                        selectedPortfolios = new Set(validSelection.length > 0 ? validSelection : portfolios);
                        console.log('Restored portfolio selection from saved state:', Array.from(selectedPortfolios));
                    } catch (e) {
                        console.error('Error parsing saved selection, defaulting to all:', e);
                        selectedPortfolios = new Set(portfolios);
                    }
                } else {
                    selectedPortfolios = new Set(portfolios);
                }

                // Restore includeCash state
                if (savedState && savedState.includeCash !== undefined) {
                    includeCash = savedState.includeCash === 'true' || savedState.includeCash === true;
                    const toggle = document.getElementById('includeCashToggle');
                    if (toggle) {
                        toggle.checked = includeCash;
                    }
                    console.log('Restored includeCash state:', includeCash);
                }

                console.log('Portfolios found:', portfolios);
                console.log('selectedPortfolios initialized:', selectedPortfolios);

                createPortfolioFilters(portfolios);
                initializeCashToggle();

                // Hide loading, show content BEFORE creating charts
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('analysisContent').style.display = 'block';

                // Small delay to ensure DOM is fully rendered before creating charts
                setTimeout(() => {
                    // Charts will use CSS-controlled dimensions (height: 100%)
                    // No explicit dimension setting needed - CSS handles sizing
                    updateCharts();

                    // Risk indicators removed - now only on main page

                    // Force ApexCharts to redraw - all charts are now visible
                    window.dispatchEvent(new Event('resize'));

                    console.log('UI initialization completed successfully');
                }, 100);
            } catch (error) {
                console.error('Error during data processing or UI initialization:', error);
                document.getElementById('loadingIndicator').innerHTML = `
                <p class="has-text-danger">Error processing data: ${error.message}</p>
                <p class="has-text-grey">Check console for more details.</p>
                <button class="button is-info mt-3" onclick="location.reload()">Try Again</button>
            `;
            }
        }).catch(error => {
            clearTimeout(loadingTimeout); // Clear the timeout since we got a response (even if error)
            console.error('Error loading data:', error);
            console.error('Error stack:', error.stack);

            // Provide more detailed error information
            let errorMessage = error.message;
            let additionalInfo = '';

            if (error.name === 'TypeError' && errorMessage.includes('fetch')) {
                errorMessage = 'Unable to connect to the server. Please check your connection and try again.';
            } else if (error.status === 401) {
                errorMessage = 'Authentication required. Please select an account from the home page first.';
                additionalInfo = 'Make sure you have selected an account before accessing this page.';
            } else if (error.status === 404) {
                errorMessage = 'API endpoint not found. Please contact support.';
            } else if (error.message && error.message.includes('Not authenticated')) {
                errorMessage = 'Authentication required. Please select an account from the home page first.';
                additionalInfo = 'You need to be logged in with a selected account to view portfolio data.';
            }

            document.getElementById('loadingIndicator').innerHTML = `
            <div class="has-text-centered">
                <p class="has-text-danger mb-3">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    Error loading data: ${errorMessage}
                </p>
                ${additionalInfo ? `<p class="has-text-grey mb-3">${additionalInfo}</p>` : ''}
                <p class="has-text-grey mb-3">
                    If this problem persists, please check the browser console for more details.
                </p>
                <div class="buttons is-centered">
                    <a href="/" class="button is-primary">
                        <i class="fas fa-home mr-2"></i>Go to Home Page
                    </a>
                <button class="button is-info" onclick="location.reload()">
                    <i class="fas fa-refresh mr-2"></i>Try Again
                </button>
                </div>
            </div>
        `;
        });

        // Fetch list of portfolios with their IDs
        async function fetchPortfolios() {
            console.log('Fetching portfolios...');
            try {
                const response = await fetch('/portfolio/api/portfolios?include_ids=true&has_companies=true');
                console.log('Portfolios API response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Portfolios API error response:', errorText);

                    // Try to parse as JSON to get structured error
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.error && errorData.error.includes('Not authenticated')) {
                            throw new Error('Not authenticated - please select an account from the home page first');
                        }
                    } catch (parseError) {
                        // Ignore parse errors, use original text
                    }

                    throw new Error(`Failed to fetch portfolios (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                console.log('Portfolios data received:', data);

                // Check if the response contains an error
                if (data.error) {
                    throw new Error(data.error);
                }

                return data;
            } catch (error) {
                console.error('Error in fetchPortfolios:', error);
                throw error;
            }
        }

        // Fetch portfolio data
        async function fetchPortfolioData() {
            console.log('Fetching portfolio data...');
            try {
                const response = await fetch('/portfolio/api/portfolio_data');
                console.log('Portfolio data API response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Portfolio data API error response:', errorText);

                    // Try to parse as JSON to get structured error
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.error && errorData.error.includes('Not authenticated')) {
                            throw new Error('Not authenticated - please select an account from the home page first');
                        }
                    } catch (parseError) {
                        // Ignore parse errors, use original text
                    }

                    throw new Error(`Failed to fetch portfolio data (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                console.log('Portfolio data received, length:', Array.isArray(data) ? data.length : 'not an array');

                // Check if the response contains an error
                if (data.error) {
                    throw new Error(data.error);
                }

                return data;
            } catch (error) {
                console.error('Error in fetchPortfolioData:', error);
                throw error;
            }
        }

        // Process the data
        function processData(portfoliosList, data) {
            console.log('Processing data:');
            console.log('Portfolios list:', portfoliosList);
            console.log('Portfolio data sample:', data.slice(0, 3)); // Log first 3 items for debugging
            console.log('Portfolio data length:', data.length);

            // Create portfolio structure
            let portfolios;
            if (portfoliosList.length > 0 && typeof portfoliosList[0] === 'object' && portfoliosList[0].id) {
                // List already contains objects with IDs
                portfolios = portfoliosList;
            } else {
                // List contains only names, create mapping with best-effort IDs
                portfolios = portfoliosList.map((name, index) => ({
                    id: index + 1,
                    name: name
                }));
            }
            console.log('Mapped portfolios:', portfolios);

            // Group data by portfolio
            const portfolioMap = {};

            data.forEach(item => {
                // Check for the correct property name for portfolio
                const portfolioName = item.portfolio || item.portfolio_name;

                if (!portfolioName) {
                    console.warn('Item has no portfolio name:', item);
                    return; // Skip items without portfolio name
                }

                if (!portfolioMap[portfolioName]) {
                    // First try to find portfolio by exact name match
                    let portfolio = portfolios.find(p => p.name === portfolioName);

                    if (!portfolio) {
                        // If not found by exact match, try case-insensitive match
                        portfolio = portfolios.find(p => p.name.toLowerCase() === portfolioName.toLowerCase());
                    }

                    if (portfolio) {
                        portfolioMap[portfolioName] = {
                            id: portfolio.id,
                            name: portfolioName,
                            companies: [],
                            totalValue: 0,
                            totalInvested: 0
                        };
                    } else {
                        // Create a fallback entry with a generated ID
                        const fallbackId = 1000 + Object.keys(portfolioMap).length;
                        portfolioMap[portfolioName] = {
                            id: fallbackId,
                            name: portfolioName,
                            companies: [],
                            totalValue: 0,
                            totalInvested: 0
                        };
                    }
                }

                if (portfolioMap[portfolioName]) {
                    // Calculate current value using centralized utility (handles custom values)
                    const currentValue = calculateItemValue(item);
                    const totalInvested = item.total_invested || 0;

                    // Keep these for individual display
                    const price = item.price_eur || 0;
                    const shares = item.effective_shares || 0;

                    // Get company name from the correct property
                    const companyName = item.company || item.name || 'Unknown';

                    // Add company to portfolio with all needed fields
                    // IMPORTANT: Include ALL fields needed by centralized value calculator
                    portfolioMap[portfolioName].companies.push({
                        id: item.id,
                        name: companyName,
                        sector: item.sector || 'Unassigned',
                        investment_type: item.investment_type || null,
                        shares: shares,
                        effective_shares: shares, // Required by centralized calculator
                        priceEur: price,
                        price_eur: price, // Required by centralized calculator
                        currentValue: currentValue, // Pre-calculated using centralized utility
                        totalInvested: totalInvested,
                        portfolioId: portfolioMap[portfolioName].id,
                        portfolioName: portfolioName,
                        // Include risk analysis fields
                        country: item.effective_country || item.country || 'Unknown',
                        exchange: item.exchange || 'Unknown',
                        thesis: item.thesis || '',
                        // Include custom value fields (required by centralized calculator)
                        is_custom_value: item.is_custom_value || false,
                        custom_total_value: item.custom_total_value || null,
                        custom_price_eur: item.custom_price_eur || null,
                        custom_value_date: item.custom_value_date || null
                    });

                    // Update portfolio totals
                    portfolioMap[portfolioName].totalValue += currentValue;
                    portfolioMap[portfolioName].totalInvested += totalInvested;
                }
            });

            // Convert map to array
            portfolioData = Object.values(portfolioMap);

            console.log(`Created ${portfolioData.length} portfolios from data`);
            portfolioData.forEach(p => {
                console.log(`Portfolio ${p.name}: ${p.companies.length} companies, Total Value: ${p.totalValue}`);
            });

            console.log('Data processing completed for Risk Overview');
        }

        function createPortfolioFilters(portfolios) {
            const pillsContainer = document.getElementById('portfolioPills');

            pillsContainer.innerHTML = '';

            // Create "All" button as first pill
            const allPill = document.createElement('div');
            allPill.className = 'portfolio-pill all-pill';
            allPill.innerHTML = `
                <div class="portfolio-pill-name">All</div>
            `;

            allPill.addEventListener('click', function () {
                portfolios.forEach(portfolio => {
                    selectedPortfolios.add(portfolio);
                });
                updatePillStates();
                updateCharts();
                savePortfolioSelection();
            });

            pillsContainer.appendChild(allPill);

            // Create portfolio pills
            portfolios.forEach(portfolioName => {
                const pill = document.createElement('div');
                pill.className = `portfolio-pill ${selectedPortfolios.has(portfolioName) ? 'selected' : ''}`;
                pill.dataset.portfolio = portfolioName;

                pill.innerHTML = `
                    <div class="portfolio-pill-name">${portfolioName}</div>
                `;

                pill.addEventListener('click', function () {
                    if (selectedPortfolios.has(portfolioName)) {
                        selectedPortfolios.delete(portfolioName);
                        pill.classList.remove('selected');
                    } else {
                        selectedPortfolios.add(portfolioName);
                        pill.classList.add('selected');
                    }
                    updateCharts();
                    savePortfolioSelection();
                });

                pillsContainer.appendChild(pill);
            });
        }

        function updatePillStates() {
            const pills = document.querySelectorAll('.portfolio-pill');
            pills.forEach(pill => {
                const portfolioName = pill.dataset.portfolio;
                if (selectedPortfolios.has(portfolioName)) {
                    pill.classList.add('selected');
                } else {
                    pill.classList.remove('selected');
                }
            });
        }

        // Update cash display in the toggle
        function updateCashDisplay() {
            const cashDisplay = document.getElementById('cashBalanceDisplay');
            if (cashDisplay) {
                if (cashBalance > 0) {
                    cashDisplay.textContent = formatCurrency(cashBalance).replace(/<[^>]*>/g, '');
                    cashDisplay.classList.add('is-visible');
                } else {
                    cashDisplay.classList.remove('is-visible');
                }
            }
        }

        // Initialize cash toggle event listener
        function initializeCashToggle() {
            const toggle = document.getElementById('includeCashToggle');
            if (toggle) {
                toggle.addEventListener('change', function() {
                    includeCash = this.checked;
                    console.log('Include cash toggled:', includeCash);
                    updateCharts();
                    savePortfolioSelection();
                });
            }
        }

        // Create virtual cash position for charts
        function createCashPosition() {
            if (!includeCash || cashBalance <= 0) return null;
            return {
                id: 'cash-virtual',
                name: 'Cash',
                company: 'Cash',
                currentValue: cashBalance,
                sector: 'Cash',
                investment_type: 'Cash',
                country: 'Cash',
                thesis: 'Cash'
            };
        }

        function updateCharts() {
            console.log('updateCharts called');
            console.log('portfolioData:', portfolioData);
            console.log('selectedPortfolios:', selectedPortfolios);

            const filteredPortfolios = portfolioData.filter(p => selectedPortfolios.has(p.name));

            console.log('filteredPortfolios:', filteredPortfolios);
            console.log('filteredPortfolios length:', filteredPortfolios.length);

            // Update contextual subtitles
            updateDashboardSubtitles(filteredPortfolios);

            if (filteredPortfolios.length === 0) {
                console.log('No data to display for selected portfolios');
                // Show empty states in dashboard cards
                showEmptyStates();
                updateDistributionCharts(); // This will show "no data"
                return;
            }

            console.log('Calling chart update functions...');
            initializePortfolioAllocationsChart();
            initializeCompanyAllocationsChart();
            updateDistributionCharts();
            // Risk indicators removed - now only on main page
        }

        function updateDashboardSubtitles(filteredPortfolios) {
            const portfolioCountEl = document.getElementById('portfolioCountSubtitle');
            const companyCountEl = document.getElementById('companyCountSubtitle');
            const countryCountEl = document.getElementById('countryCountSubtitle');
            const sectorCountEl = document.getElementById('sectorCountSubtitle');
            const thesisCountEl = document.getElementById('thesisCountSubtitle');


            if (filteredPortfolios.length === 0) {
                portfolioCountEl.textContent = 'No portfolios selected';
                companyCountEl.textContent = 'Select portfolios to view';
                countryCountEl.textContent = '';
                sectorCountEl.textContent = '';
                if (thesisCountEl) thesisCountEl.textContent = '';

                return;
            }

            // Update portfolio count
            portfolioCountEl.textContent = `${filteredPortfolios.length} portfolio${filteredPortfolios.length > 1 ? 's' : ''} selected`;

            // Calculate company count across selected portfolios
            const allCompanies = getAllCompaniesFromSelectedPortfolios();
            const uniqueCompanies = new Set(allCompanies.map(c => c.name));
            companyCountEl.textContent = `${uniqueCompanies.size} unique companies`;

            // Calculate distribution counts
            const countries = new Set(allCompanies.map(c => c.country || 'Unknown'));
            const sectors = new Set(allCompanies.map(c => c.sector || 'Unknown'));
            const theses = new Set(allCompanies.map(c => c.thesis || 'Unassigned').filter(t => t && t !== 'Unassigned'));
            const unassignedThesisCount = allCompanies.filter(c => !c.thesis || c.thesis === '').length;


            countryCountEl.textContent = `${countries.size} countries`;
            sectorCountEl.textContent = `${sectors.size} sectors`;
            if (thesisCountEl) {
                if (theses.size === 0) {
                    thesisCountEl.textContent = 'No thesis assigned';
                } else {
                    thesisCountEl.textContent = `${theses.size} thesis${theses.size > 1 ? 'es' : ''}${unassignedThesisCount > 0 ? `, ${unassignedThesisCount} unassigned` : ''}`;
                }
            }

        }

        function showEmptyStates() {
            const chartIds = [
                'portfolioAllocationsChart',
                'companyAllocationsChart',
                'countryDistributionChart',
                'sectorDistributionChart',
                'investmentTypeChart',
                'thesisDistributionChart'
            ];

            chartIds.forEach(chartId => {
                const element = document.getElementById(chartId);
                if (element) {
                    element.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ“Š</div>
                            <p>No portfolio selected</p>
                        </div>
                    `;
                }
            });


        }

        function initializePortfolioAllocationsChart() {
            const filteredPortfolios = portfolioData.filter(p => selectedPortfolios.has(p.name));
            const labels = filteredPortfolios.map(p => p.name);
            const values = filteredPortfolios.map(p => p.totalValue);

            // Validate and clean data
            const cleanedData = [];
            for (let i = 0; i < labels.length; i++) {
                const value = parseFloat(values[i]) || 0;
                if (value > 0 && !isNaN(value)) {
                    cleanedData.push({
                        label: labels[i],
                        value: value
                    });
                }
            }

            // Add cash as separate entry when toggle is enabled
            if (includeCash && cashBalance > 0) {
                cleanedData.push({
                    label: 'Cash',
                    value: cashBalance
                });
            }

            console.log('Portfolio chart cleaned data:', cleanedData);

            if (cleanedData.length === 0) {
                document.getElementById('portfolioAllocationsChart').innerHTML =
                    '<div class="has-text-centered p-4"><p class="has-text-grey-light">No data available</p></div>';
                return;
            }

            const cleanedLabels = cleanedData.map(d => d.label);
            const cleanedValues = cleanedData.map(d => d.value);

            console.log('Portfolio chart - labels:', cleanedLabels);
            console.log('Portfolio chart - values:', cleanedValues);

            try {
                const chartElement = document.getElementById('portfolioAllocationsChart');
                if (!chartElement) {
                    console.error('Portfolio chart element not found');
                    return;
                }

                // Ensure the element is visible - dimensions controlled by CSS
                chartElement.style.display = 'block';

                if (typeof ChartConfig !== 'undefined' && ChartConfig.createStandardDoughnutChart) {
                    ChartConfig.createStandardDoughnutChart(
                        'portfolioAllocationsChart',
                        cleanedLabels,
                        cleanedValues,
                        {
                            title: '',
                            showTotal: true,
                            height: 350
                            // Colors will be automatically assigned consistently based on labels
                        }
                    );
                } else {
                    console.error('ChartConfig.createStandardDoughnutChart not available');
                    document.getElementById('portfolioAllocationsChart').innerHTML =
                        '<div class="has-text-centered p-4"><p class="has-text-grey-light">Chart library not loaded</p></div>';
                }
            } catch (error) {
                console.error('Error creating portfolio allocations chart:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('portfolioAllocationsChart').innerHTML =
                    '<div class="has-text-centered p-4"><p class="has-text-danger">Error creating chart: ' + error.message + '</p></div>';
            }
        }

        function initializeCompanyAllocationsChart() {
            const allCompanies = getAllCompaniesFromSelectedPortfolios();
            const companyGroups = groupCompaniesByName(allCompanies);

            // Prepare chart data (handles top 10 + "Others")
            const { labels, values } = prepareChartData(companyGroups);

            if (labels.length === 0) {
                document.getElementById('companyAllocationsChart').innerHTML =
                    '<div class="has-text-centered p-4"><p class="has-text-grey-light">No data available</p></div>';
                return;
            }

            // Calculate total and percentages for the bar chart
            const totalValue = values.reduce((sum, v) => sum + v, 0);
            const percentages = values.map(v => totalValue > 0 ? (v / totalValue) * 100 : 0);

            try {
                // Use the existing bar chart function
                createBarChart('companyAllocationsChart',
                    labels,
                    values, {
                    title: '',
                    colors: ChartConfig.generateColors(labels.length),
                    percentages: percentages,
                    total: totalValue,
                    formatPercentage: window.formatPercentage || (v => `${v.toFixed(1)}%`),
                    height: 350
                }
                );
            } catch (error) {
                console.error('Error creating company allocations bar chart:', error);
                document.getElementById('companyAllocationsChart').innerHTML =
                    '<div class="has-text-centered p-4"><p class="has-text-danger">Error creating chart: ' + error.message + '</p></div>';
            }
        }

        // Get all companies from selected portfolios with additional metadata
        function getAllCompaniesFromSelectedPortfolios() {
            // Check if there are any selected portfolios
            if (selectedPortfolios.size === 0) {
                console.log('No portfolios selected, returning empty array');
                return [];
            }

            const companies = portfolioData
                .filter(p => selectedPortfolios.has(p.name))
                .flatMap(p => p.companies);

            // Ensure companies have calculated currentValue and metadata fields
            const result = companies.map(company => {
                // Calculate currentValue using centralized utility (handles custom values)
                if (typeof company.currentValue === 'undefined') {
                    company.currentValue = calculateItemValue(company);
                }

                // Ensure metadata fields exist
                company.country = company.country || 'Unknown';
                company.sector = company.sector || 'Unknown';
                company.investment_type = company.investment_type || null;
                company.exchange = company.exchange || 'Unknown';

                return company;
            });

            // Append virtual cash position if toggle is enabled
            const cashPosition = createCashPosition();
            if (cashPosition) {
                result.push(cashPosition);
            }

            return result;
        }

        // Group companies by name and sum values
        function groupCompaniesByName(companies) {
            const companyMap = {};

            companies.forEach(company => {
                const name = company.name;
                if (!companyMap[name]) {
                    companyMap[name] = {
                        name: name,
                        currentValue: 0,
                        shares: 0,
                        totalInvested: 0,
                        // Preserve metadata from the first occurrence
                        sector: company.sector || 'Unknown',
                        country: company.country || 'Unknown',
                        investment_type: company.investment_type || null,
                        exchange: company.exchange || 'Unknown'
                    };
                }

                // Sum up values
                companyMap[name].currentValue += company.currentValue || 0;
                companyMap[name].shares += company.effective_shares || 0;
                companyMap[name].totalInvested += company.totalInvested || 0;
            });

            // Convert to array and sort by value
            return Object.values(companyMap).sort((a, b) => b.currentValue - a.currentValue);
        }

        // Prepare chart data (labels and values)
        function prepareChartData(companies) {
            // Sort by value
            const sortedCompanies = [...companies].sort((a, b) => b.currentValue - a.currentValue);

            let labels = [];
            let values = [];

            if (sortedCompanies.length > 10) {
                // Take top 10 companies
                const top10 = sortedCompanies.slice(0, 10);
                const others = sortedCompanies.slice(10);

                labels = top10.map(c => c.name);
                values = top10.map(c => c.currentValue);

                // Add "Others" sector
                const othersTotal = others.reduce((sum, c) => sum + c.currentValue, 0);
                if (othersTotal > 0) {
                    labels.push('Others');
                    values.push(othersTotal);
                }
            } else {
                labels = sortedCompanies.map(c => c.name);
                values = sortedCompanies.map(c => c.currentValue);
            }

            return { labels, values };
        }

        // Helper function to truncate text to a maximum length
        function truncateText(text, maxLength = 25) {
            if (!text) return '';
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // Create bar chart with rotated x-axis labels
        function createBarChart(chartId, labels, values, options = {}) {
            const element = document.getElementById(chartId);
            if (!element) {
                console.error(`Chart element ${chartId} not found`);
                return;
            }

            // Clear existing chart
            element.innerHTML = '';

            // Convert values to percentages
            const total = options.total || values.reduce((sum, v) => sum + v, 0);
            const percentageValues = values.map(val => total > 0 ? (val / total * 100) : 0);

            const colors = options.colors || ChartConfig.generateColors(labels.length);

            const chartOptions = {
                series: [{
                    name: 'Percentage',
                    data: percentageValues
                }],
                chart: {
                    type: 'bar',
                    height: options.height || 350,
                    toolbar: {
                        show: false
                    }
                },
                plotOptions: {
                    bar: {
                        horizontal: false,
                        columnWidth: '55%',
                        endingShape: 'rounded',
                        distributed: true
                    },
                },
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    show: true,
                    width: 2,
                    colors: ['transparent']
                },
                xaxis: {
                    categories: labels,
                    labels: {
                        rotate: -45,
                        rotateAlways: true,
                        style: {
                            fontSize: '12px',
                            fontWeight: 400
                        },
                        maxHeight: 120
                    }
                },
                yaxis: {
                    labels: {
                        formatter: function (val) {
                            return val.toFixed(1) + '%';
                        }
                    }
                },
                fill: {
                    opacity: 1,
                    colors: colors
                },
                tooltip: {
                    custom: function ({ series, seriesIndex, dataPointIndex, w }) {
                        try {
                            const label = w.globals.labels[dataPointIndex];
                            const value = series[seriesIndex][dataPointIndex];

                            // Get company details for this sector
                            const companies = options.companyDetails?.[label] || [];

                            let companyList = '';
                            if (companies.length > 0) {
                                // Show up to 10 companies, sorted by value
                                const displayCount = Math.min(companies.length, 10);
                                companyList = companies.slice(0, displayCount).map(company =>
                                    `<div style="margin: 2px 0; display: flex; justify-content: space-between; align-items: center; overflow: hidden;">
                                        <span style="margin-right: 8px; overflow: hidden; white-space: nowrap;">${truncateText(company.name, 25)}</span>
                                        <span style="font-weight: bold; flex-shrink: 0; white-space: nowrap;">${company.percentage.toFixed(2)}%</span>
                                    </div>`
                                ).join('');

                                if (companies.length > displayCount) {
                                    companyList += `<div style="margin-top: 4px; font-style: italic; color: #888;">... and ${companies.length - displayCount} more</div>`;
                                }
                            } else {
                                companyList = '<div style="font-style: italic; color: #888;">No companies in this sector</div>';
                            }

                            return `<div style="padding: 12px; background: rgba(0,0,0,0.85); color: white; border-radius: 8px; font-size: 12px; max-width: 300px; overflow: hidden; box-sizing: border-box;">
                                <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 4px;">
                                    ${truncateText(label, 25)}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>Total Allocation: ${value.toFixed(2)}%</strong>
                                </div>
                                <div style="margin-bottom: 4px; font-weight: bold;">Companies (${companies.length}):</div>
                                <div>
                                    ${companyList}
                                </div>
                            </div>`;
                        } catch (error) {
                            console.error('Tooltip error:', error);
                            const label = w.globals.labels[dataPointIndex];
                            const value = series[seriesIndex][dataPointIndex];
                            return `<div style="padding: 8px;">${truncateText(label, 25)}: ${value.toFixed(1)}%</div>`;
                        }
                    }
                },
                legend: {
                    show: false
                },
                colors: colors
            };

            const chart = new ApexCharts(element, chartOptions);
            chart.render();

            return chart;
        }

        // Helper function to get display country for geographic spread
        function getDisplayCountry(company) {
            // Check if this is a cryptocurrency based on identifier pattern
            const identifier = company.identifier || '';
            if (identifier.includes('-USD') || identifier.includes('BTC') || identifier.includes('ETH')) {
                return 'Crypto';
            }

            // For non-crypto assets, use effective_country with fallback
            return (company.effective_country || company.country || '').trim() || 'Unknown';
        }

        function updateDistributionCharts() {
            updateDistributionChart('country', 'countryDistributionChart');
            updateDistributionChart('sector', 'sectorDistributionChart');
            updateInvestmentTypeChart();
            updateThesisChart();
        }

        function updateDistributionChart(field, chartId) {
            const distributions = {};
            const companyDetails = {}; // Track companies in each sector

            // Get all companies from selected portfolios
            const allCompanies = getAllCompaniesFromSelectedPortfolios();

            allCompanies.forEach(company => {
                const value = company.currentValue || 0;

                // Use helper function for country field to handle crypto display
                let key;
                if (field === 'country') {
                    key = getDisplayCountry(company);
                } else {
                    key = company[field] || 'Unknown';
                }

                distributions[key] = (distributions[key] || 0) + value;

                // Track company details for tooltips
                if (!companyDetails[key]) companyDetails[key] = [];
                companyDetails[key].push({
                    name: company.name,
                    value: value,
                    percentage: 0 // Will be calculated later
                });
            });

            const distributionData = Object.entries(distributions)
                .map(([name, value]) => ({ name, value }))
                .sort((a, b) => b.value - a.value);

            // Clear existing chart
            document.getElementById(chartId).innerHTML = '';

            if (distributionData.length === 0) {
                document.getElementById(chartId).innerHTML = '<p class="has-text-grey has-text-centered p-4">No data available</p>';
                return;
            }

            // Calculate percentages for better display
            const distributionTotal = distributionData.reduce((sum, item) => sum + item.value, 0);
            const distributionPercentages = distributionData.map(item => distributionTotal > 0 ? (item.value / distributionTotal) * 100 : 0);

            // Calculate individual company percentages and sort by value
            for (const key in companyDetails) {
                companyDetails[key].forEach(company => {
                    company.percentage = distributionTotal > 0 ? (company.value / distributionTotal) * 100 : 0;
                });
                companyDetails[key].sort((a, b) => b.value - a.value);
            }

            try {
                // Create bar chart with enhanced tooltips
                createBarChart(chartId,
                    distributionData.map(item => item.name),
                    distributionData.map(item => item.value), {
                    title: '',
                    colors: ChartConfig.generateColors(distributionData.length),
                    percentages: distributionPercentages,
                    total: distributionTotal,
                    formatPercentage: window.formatPercentage || (v => `${v.toFixed(1)}%`),
                    height: 350,
                    companyDetails: companyDetails // Pass company details for tooltips
                });
            } catch (error) {
                console.error(`Error creating ${field} distribution chart:`, error);
                document.getElementById(chartId).innerHTML = '<p class="has-text-danger">Error creating chart</p>';
            }
        }

        function updateInvestmentTypeChart() {
            const chartId = 'investmentTypeChart';
            const distributions = {};
            const companyDetails = {}; // Track companies in each type

            // Get all companies from selected portfolios
            const allCompanies = getAllCompaniesFromSelectedPortfolios();

            allCompanies.forEach(company => {
                const value = company.currentValue || 0;
                const type = company.investment_type || 'Unassigned';

                distributions[type] = (distributions[type] || 0) + value;

                // Track company details for tooltips
                if (!companyDetails[type]) companyDetails[type] = [];
                companyDetails[type].push({
                    name: company.name,
                    value: value,
                    percentage: 0 // Will be calculated later
                });
            });

            const distributionData = Object.entries(distributions)
                .map(([name, value]) => ({ name, value }))
                .sort((a, b) => b.value - a.value);

            // Update subtitle with count
            const investmentTypeSubtitle = document.getElementById('investmentTypeSubtitle');
            if (investmentTypeSubtitle) {
                const stockCount = companyDetails['Stock'] ? companyDetails['Stock'].length : 0;
                const etfCount = companyDetails['ETF'] ? companyDetails['ETF'].length : 0;
                const unassignedCount = companyDetails['Unassigned'] ? companyDetails['Unassigned'].length : 0;
                investmentTypeSubtitle.textContent = `${stockCount} Stocks, ${etfCount} ETFs`;
                if (unassignedCount > 0) {
                    investmentTypeSubtitle.textContent += `, ${unassignedCount} Unassigned`;
                }
            }

            // Clear existing chart
            document.getElementById(chartId).innerHTML = '';

            if (distributionData.length === 0) {
                document.getElementById(chartId).innerHTML = '<p class="has-text-grey has-text-centered p-4">No data available</p>';
                return;
            }

            // Calculate percentages
            const distributionTotal = distributionData.reduce((sum, item) => sum + item.value, 0);
            const distributionPercentages = distributionData.map(item => distributionTotal > 0 ? (item.value / distributionTotal) * 100 : 0);

            // Calculate individual company percentages
            for (const key in companyDetails) {
                companyDetails[key].forEach(company => {
                    company.percentage = distributionTotal > 0 ? (company.value / distributionTotal) * 100 : 0;
                });
                companyDetails[key].sort((a, b) => b.value - a.value);
            }

            // Use consistent colors from ChartConfig for investment types
            const colors = ChartConfig.getConsistentColors(distributionData.map(item => item.name));

            try {
                // Create doughnut chart
                ChartConfig.createStandardDoughnutChart(
                    chartId,
                    distributionData.map(item => item.name),
                    distributionData.map(item => item.value),
                    {
                        title: '',
                        colors: colors,
                        showTotal: true,
                        height: 350
                    }
                );
            } catch (error) {
                console.error('Error creating investment type distribution chart:', error);
                document.getElementById(chartId).innerHTML = '<p class="has-text-danger">Error creating chart</p>';
            }
        }

        function updateThesisChart() {
            const chartId = 'thesisDistributionChart';
            const distributions = {};
            const companyDetails = {}; // Track companies in each thesis

            // Get all companies from selected portfolios
            const allCompanies = getAllCompaniesFromSelectedPortfolios();

            allCompanies.forEach(company => {
                const value = company.currentValue || 0;
                const thesis = company.thesis && company.thesis.trim() ? company.thesis.trim() : 'Unassigned';

                distributions[thesis] = (distributions[thesis] || 0) + value;

                // Track company details for tooltips
                if (!companyDetails[thesis]) companyDetails[thesis] = [];
                companyDetails[thesis].push({
                    name: company.name,
                    value: value,
                    percentage: 0 // Will be calculated later
                });
            });

            const distributionData = Object.entries(distributions)
                .map(([name, value]) => ({ name, value }))
                .sort((a, b) => b.value - a.value);

            // Clear existing chart
            document.getElementById(chartId).innerHTML = '';

            if (distributionData.length === 0) {
                document.getElementById(chartId).innerHTML = '<p class="has-text-grey has-text-centered p-4">No data available</p>';
                return;
            }

            // Calculate percentages
            const distributionTotal = distributionData.reduce((sum, item) => sum + item.value, 0);
            const distributionPercentages = distributionData.map(item => distributionTotal > 0 ? (item.value / distributionTotal) * 100 : 0);

            // Calculate individual company percentages
            for (const key in companyDetails) {
                companyDetails[key].forEach(company => {
                    company.percentage = distributionTotal > 0 ? (company.value / distributionTotal) * 100 : 0;
                });
                companyDetails[key].sort((a, b) => b.value - a.value);
            }

            try {
                // Create bar chart with enhanced tooltips (same as sector chart)
                createBarChart(chartId,
                    distributionData.map(item => item.name),
                    distributionData.map(item => item.value), {
                    title: '',
                    colors: ChartConfig.generateColors(distributionData.length),
                    percentages: distributionPercentages,
                    total: distributionTotal,
                    formatPercentage: window.formatPercentage || (v => `${v.toFixed(1)}%`),
                    height: 350,
                    companyDetails: companyDetails // Pass company details for tooltips
                });
            } catch (error) {
                console.error('Error creating thesis distribution chart:', error);
                document.getElementById(chartId).innerHTML = '<p class="has-text-danger">Error creating chart</p>';
            }
        }

        // Risk indicator functions removed - now only available on main page
    });
</script>

{% endblock %}