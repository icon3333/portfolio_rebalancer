#!/bin/bash

# Portfolio Rebalancer - Automated Docker Deployment Script
# This script handles complete deployment including data migration

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
APP_NAME="portfolio_rebalancer"
CONTAINER_NAME="portfolio_rebalancer"
PORT="8065"
DATA_DIR="/data"
BACKUP_DIR="/data/backups"

echo -e "${BLUE}ðŸš€ Portfolio Rebalancer - Docker Deployment${NC}"
echo "=================================================="

# Function to print colored output
log_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
log_success() { echo -e "${GREEN}âœ… $1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
log_error() { echo -e "${RED}âŒ $1${NC}"; }

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   log_warning "Running as root. This is not recommended for production."
   read -p "Continue anyway? (y/N): " -n 1 -r
   echo
   if [[ ! $REPLY =~ ^[Yy]$ ]]; then
       exit 1
   fi
fi

# Check if Docker and Docker Compose are installed
check_dependencies() {
    log_info "Checking dependencies..."
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed. Please install Docker first."
        exit 1
    fi
    
    # Detect docker compose command (new vs old syntax)
    if docker compose version &> /dev/null; then
        DOCKER_COMPOSE_CMD="docker compose"
        log_info "Using new Docker Compose syntax: docker compose"
    elif command -v docker-compose &> /dev/null; then
        DOCKER_COMPOSE_CMD="docker-compose"
        log_info "Using legacy Docker Compose syntax: docker-compose"
    else
        log_error "Docker Compose is not installed. Please install Docker Compose first."
        exit 1
    fi
    
    log_success "Dependencies check passed"
}

# Create necessary directories
setup_directories() {
    log_info "Setting up directories..."
    
    sudo mkdir -p "$DATA_DIR/database/backups"
    sudo mkdir -p "$DATA_DIR/uploads" 
    sudo mkdir -p "$BACKUP_DIR"
    
    # Set proper permissions
    sudo chown -R $(id -u):$(id -g) "$DATA_DIR"
    sudo chmod -R 755 "$DATA_DIR"
    
    log_success "Directories created: $DATA_DIR"
}

# Generate secure environment file
setup_environment() {
    log_info "Setting up environment configuration..."
    
    if [[ -f .env ]]; then
        log_warning ".env file already exists"
        read -p "Overwrite existing .env file? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Using existing .env file"
            return
        fi
        cp .env .env.backup.$(date +%s)
        log_info "Backed up existing .env file"
    fi
    
    # Generate secure secret key
    SECRET_KEY=$(python3 -c "import secrets; print(secrets.token_hex(32))")
    
    # Create .env file
    cat > .env << EOF
# Portfolio Rebalancer Environment Configuration
# Generated by deploy.sh on $(date)

SECRET_KEY=$SECRET_KEY
DATABASE_URL=sqlite:////data/database/portfolio.db
FLASK_ENV=production
PYTHONUNBUFFERED=1
EOF
    
    log_success "Environment file created with secure secret key"
}

# Migrate existing database if present
migrate_existing_data() {
    log_info "Checking for existing database..."
    
    # Check for existing database in current directory
    if [[ -f "app/database/portfolio.db" ]]; then
        log_warning "Found existing database in app/database/portfolio.db"
        read -p "Migrate existing database to production location? (Y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            # Create backup of existing data
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            cp "app/database/portfolio.db" "$BACKUP_DIR/migration_backup_$TIMESTAMP.db"
            log_success "Backup created: $BACKUP_DIR/migration_backup_$TIMESTAMP.db"
            
            # Copy to production location
            cp "app/database/portfolio.db" "$DATA_DIR/database/portfolio.db"
            
            # Copy any existing backups
            if [[ -d "app/database/backups" ]] && [[ "$(ls -A app/database/backups)" ]]; then
                cp app/database/backups/* "$DATA_DIR/database/backups/" 2>/dev/null || true
                log_success "Existing backups migrated"
            fi
            
            log_success "Database migrated to $DATA_DIR/database/portfolio.db"
        fi
    else
        log_info "No existing database found - will create new one"
    fi
}

# Stop existing container if running
stop_existing_container() {
    log_info "Checking for existing containers..."
    
    if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then
        log_warning "Stopping existing container: $CONTAINER_NAME"
        $DOCKER_COMPOSE_CMD down || docker stop "$CONTAINER_NAME" || true
        log_success "Existing container stopped"
    fi
}

# Build and start the application
deploy_application() {
    log_info "Building and deploying application..."
    
    # Build the Docker image
    log_info "Building Docker image..."
    $DOCKER_COMPOSE_CMD build --no-cache
    
    # Start the application
    log_info "Starting application..."
    $DOCKER_COMPOSE_CMD up -d
    
    # Wait for application to be ready
    log_info "Waiting for application to start..."
    sleep 10
    
    # Check if container is running
    if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then
        log_success "Container is running"
    else
        log_error "Container failed to start"
        log_info "Showing container logs for debugging:"
        $DOCKER_COMPOSE_CMD logs --tail=50
        log_info "Check if the /data directory has proper permissions and the .env file is correctly configured"
        exit 1
    fi
}

# Verify deployment
verify_deployment() {
    log_info "Verifying deployment..."
    
    # Wait a bit more for full startup
    sleep 5
    
    # Check health endpoint
    for i in {1..10}; do
        if curl -f http://localhost:$PORT/health &>/dev/null; then
            log_success "Health check passed"
            break
        elif [[ $i -eq 10 ]]; then
            log_error "Health check failed after 10 attempts"
            $DOCKER_COMPOSE_CMD logs --tail=50
            exit 1
        else
            log_info "Health check attempt $i/10..."
            sleep 3
        fi
    done
    
    # Display status
    echo
    log_success "ðŸŽ‰ Deployment completed successfully!"
    echo
    echo "ðŸ“Š Application Status:"
    echo "  - URL: http://localhost:$PORT"
    echo "  - Health: http://localhost:$PORT/health" 
    echo "  - Container: $CONTAINER_NAME"
    echo "  - Data Directory: $DATA_DIR"
    echo
    echo "ðŸ”§ Management Commands:"
    echo "  - View logs: $DOCKER_COMPOSE_CMD logs -f"
    echo "  - Stop app: $DOCKER_COMPOSE_CMD down"
    echo "  - Restart: $DOCKER_COMPOSE_CMD restart"
    echo "  - Update: git pull && $DOCKER_COMPOSE_CMD build && $DOCKER_COMPOSE_CMD up -d"
}

# Display usage information
show_usage() {
    echo "Usage: $0 [options]"
    echo "Options:"
    echo "  --port PORT     Use custom port (default: 8065)"
    echo "  --data-dir DIR  Use custom data directory (default: /data)"
    echo "  --help          Show this help message"
    exit 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --port)
            PORT="$2"
            shift 2
            ;;
        --data-dir)
            DATA_DIR="$2"
            BACKUP_DIR="$DATA_DIR/backups"
            shift 2
            ;;
        --help)
            show_usage
            ;;
        *)
            log_error "Unknown option: $1"
            show_usage
            ;;
    esac
done

# Main deployment process
main() {
    echo "Starting deployment with:"
    echo "  - Port: $PORT"
    echo "  - Data Directory: $DATA_DIR"
    echo
    
    check_dependencies
    setup_directories
    setup_environment
    migrate_existing_data
    stop_existing_container
    deploy_application
    verify_deployment
}

# Handle script interruption
trap 'log_error "Deployment interrupted"; exit 1' INT

# Run main function
main

log_success "Deployment script completed!" 